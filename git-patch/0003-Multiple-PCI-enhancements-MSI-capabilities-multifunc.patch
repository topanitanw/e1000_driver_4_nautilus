From 2b7b38266cb417e1b9389c319001b4dc4013e0a5 Mon Sep 17 00:00:00 2001
From: Peter Dinda <pdinda@northwestern.edu>
Date: Wed, 23 Aug 2017 15:35:23 -0500
Subject: [PATCH 3/3] Multiple PCI enhancements (MSI, capabilities,
 multifunction, others)

- Message Signaled Interrupt (MSI, not MSI-X) support
- Proper enumeration of multifunction devices
- Avoid scanning a bus more than once due to a buggy or
  strange "hierarchy"

The current protocol for using MSI is documented in the comments
in pci.h
---
 include/dev/pci.h |  94 ++++++++-
 src/dev/pci.c     | 573 ++++++++++++++++++++++++++++++++++++++++++++++++------
 2 files changed, 601 insertions(+), 66 deletions(-)

diff --git a/include/dev/pci.h b/include/dev/pci.h
index 6458d3d..61cf18f 100644
--- a/include/dev/pci.h
+++ b/include/dev/pci.h
@@ -11,12 +11,13 @@
  * http://xstack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
+ * Copyright (c) 2017, Peter Dinda <pdinda@northwestern.edu>
  * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
  *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
  * All rights reserved.
  *
- * Author: Kyle C. Hale <kh@u.northwestern.edu>
- *
+ * Authors: Kyle C. Hale <kh@u.northwestern.edu>
+ *          Peter Dinda <pdinda@northwestern.edu>
  * This is free software.  You are permitted to use,
  * redistribute, and modify it as specified in the file "LICENSE.txt".
  */
@@ -164,11 +165,30 @@ struct pci_cfg_space {
 } __packed;
 
 
+typedef enum {PCI_MSI_NONE=0, PCI_MSI_32, PCI_MSI_64, PCI_MSI_32_PER_VEC, PCI_MSI_64_PER_VEC} pci_msi_type_t;
+
+struct pci_msi_info {
+  int              enabled;
+  pci_msi_type_t   type;
+  uint8_t          co;  // offset of capability in the config space
+
+  // these come from a query of the device
+  int       num_vectors_needed;
+  
+  // these come from the user -  these reflect how the
+  // user configured the device
+  int       base_vec; // interrupt will occur on [vec,vec+num_vecs_used)
+  int       num_vecs; 
+  int       target_cpu;
+};
+
 struct pci_dev {
     uint32_t num;
+    uint32_t fun;
     struct pci_bus * bus;
     struct list_head dev_node;
-    struct pci_cfg_space cfg;
+    struct pci_cfg_space cfg;   // only a snapshot at boot!
+    struct pci_msi_info  msi;   
 };
 
 
@@ -187,6 +207,8 @@ uint32_t pci_cfg_readl(uint8_t bus, uint8_t slot, uint8_t fun, uint8_t off);
 void pci_cfg_writew(uint8_t bus, uint8_t slot, uint8_t fun, uint8_t off, uint16_t val);
 void pci_cfg_writel(uint8_t bus, uint8_t slot, uint8_t fun, uint8_t off, uint32_t val);
 
+
+
 int pci_init (struct naut_info * naut);
 
 // vendor or device -1 means match all, otherwise
@@ -199,6 +221,72 @@ int pci_dump_device_list();
 // find device structure given location
 struct pci_dev *pci_find_device(uint8_t bus, uint8_t slot, uint8_t fun);
 
+// find matching devices by vendor_id/dev_id
+// on input *num => number of slots available in array
+// on output *num => number of slots used in array
+int pci_find_matching_devices(uint16_t vendor_id, uint16_t device_id,
+			      struct pci_dev *dev[], uint32_t *num);
+
+uint16_t pci_dev_cfg_readw(struct pci_dev *dev, uint8_t off);
+uint32_t pci_dev_cfg_readl(struct pci_dev *dev, uint8_t off);
+void     pci_dev_cfg_writew(struct pci_dev *dev, uint8_t off, uint16_t val);
+void     pci_dev_cfg_writel(struct pci_dev *dev, uint8_t off, uint32_t val);
+
+// returns the offset in the config space of the capability
+// or zero if the capability does not exist
+uint8_t  pci_dev_get_capability(struct pci_dev *dev, uint8_t cap_id);
+
+// target cpu must currently be a single, physical cpu
+// after enabling, msi is *off* and the mask bits (if available)
+// are set.   In other words, this brings up MSI, but leaves it
+// in a MASKED state.  An unmask is needed
+int pci_dev_enable_msi(struct pci_dev *dev, int base_vec, int num_vecs, 
+		       int target_cpu);
+		       
+// if there is no per-vec masking, then this will mask/unmask all
+// vec=-1 means to unmask all vectors on the device
+int pci_dev_mask_msi(struct pci_dev *dev, int vec);
+int pci_dev_unmask_msi(struct pci_dev *dev, int vec);
+
+// this makes no sense with no per-vec masking
+// with no per-vec masking, it always returns 0
+// with per-vec masking it returns the pending bit
+int pci_dev_is_pending_msi(struct pci_dev *dev, int vec);
+
+/*
+  There is currently no specific support for registering MSI interrupt handlers,
+  You want to follow roughly these steps:
+
+  struct pci_dev *d = ... find the device... - it must have MSI...
+  int num_vecs = d->msi.num_vectors_needed;
+
+  int base_vec;
+
+  // try to find an aligned chunk of vectors we can use
+  // note that prioritization here is your problem
+  if (idt_find_and_reserve_range(num_vecs,aligned=1,&base_vec) {
+     // fail - cannot find aligned block of vectors
+  }
+  if (pci_dev_enable_msi(d,base_vec,num_vecs, target_cpu=?) {
+     // failed to enable...
+  }
+  // now register your handlers
+  for (i=base_vec;i<base_vec+num_vecs;i++) { 
+     if (register_int_handler(i, handler, state)) { 
+         // failed.... 
+     }
+  }
+  // Now we can unmask 
+  for (i=base_vec;i<base_vec+num_vecs;i++) { 
+     if (pci_dev_unmask_msi(d, i)) {
+         // failed.... 
+     }
+  }
+  // now we should be seeing interrupts
+*/
+ 
+
+
 // print out human readable config space info for device on the VC
 int pci_dump_device(struct pci_dev *d);
 
diff --git a/src/dev/pci.c b/src/dev/pci.c
index 4ca4003..2a5328a 100644
--- a/src/dev/pci.c
+++ b/src/dev/pci.c
@@ -11,11 +11,13 @@
  * http://xtack.sandia.gov/hobbes
  *
  * Copyright (c) 2015, Kyle C. Hale <kh@u.northwestern.edu>
+ * Copyright (c) 2017, Peter Dinda <pdinda@northwestern.edu>
  * Copyright (c) 2015, The V3VEE Project  <http://www.v3vee.org> 
  *                     The Hobbes Project <http://xstack.sandia.gov/hobbes>
  * All rights reserved.
  *
- * Author: Kyle C. Hale <kh@u.northwestern.edu>
+ * Authors: Kyle C. Hale <kh@u.northwestern.edu>
+ *          Peter Dinda <pdinda@northwestern.edu>
  *
  * This is free software.  You are permitted to use,
  * redistribute, and modify it as specified in the file "LICENSE.txt".
@@ -132,9 +134,9 @@ pci_cfg_writel (uint8_t bus,
 
 
 static inline uint16_t
-pci_dev_valid (uint8_t bus, uint8_t slot)
+pci_dev_valid (uint8_t bus, uint8_t slot, uint8_t fun)
 {
-    return (pci_cfg_readw(bus, slot, 0, 0) != 0xffff);
+    return (pci_cfg_readw(bus, slot, fun, 0) != 0xffff);
 }
 
 
@@ -191,7 +193,7 @@ pci_add_dev_to_bus (struct pci_dev * dev,
                     struct pci_bus * bus)
 {
     dev->bus = bus;
-    list_add(&(dev->dev_node), &(bus->dev_list));
+    list_add_tail(&(dev->dev_node), &(bus->dev_list));
 }
 
 static void
@@ -200,13 +202,63 @@ pci_copy_cfg_space(struct pci_dev *dev, struct pci_bus *bus)
   uint32_t i;
   // 4 bytes at a time
   for (i=0;i<sizeof(dev->cfg);i+=4) {
-    ((uint32_t*)(&dev->cfg))[i/4] = pci_cfg_readl(bus->num,dev->num,0,i);
+    ((uint32_t*)(&dev->cfg))[i/4] = pci_cfg_readl(bus->num,dev->num,dev->fun,i);
   }
 }
 
+// this must run after copying the config space
+// and adding the device to a bus
+static void pci_msi_detect(struct pci_dev *d)
+{
+  uint8_t co = pci_dev_get_capability(d, 0x5);
+  if (!co) { 
+    //PCI_DEBUG("device does not have MSI capability\n");
+    return;
+  }
+
+  //PCI_DEBUG("device has MSI capabilitity\n");
+
+  d->msi.co = co;
+
+  uint16_t ctrl = pci_dev_cfg_readw(d,co+2);
+
+  int has_64=0, has_pervec=0, num_vec=0;
+  
+  //PCI_DEBUG("initial msi ctrl reg is %x\n", ctrl);
+  if (ctrl & 0x80) { 
+    has_64 = 1;
+  }
+  if (ctrl & 0x100) { 
+    has_pervec = 1;
+  }
+  if (has_64) {
+    if (has_pervec) { 
+      d->msi.type = PCI_MSI_64_PER_VEC;
+    } else {
+      d->msi.type = PCI_MSI_64;
+    }
+  } else {
+    if (has_pervec) { 
+      d->msi.type = PCI_MSI_32_PER_VEC;
+    } else {
+      d->msi.type = PCI_MSI_32;
+    }
+  }
+
+  d->msi.num_vectors_needed = 1 << ((ctrl >> 1) & 0x7);
+  
+  PCI_DEBUG("device has MSI of type \"%s\" num_vec=%d\n",
+	    d->msi.type == PCI_MSI_32 ? "32 bit MSI" :
+	    d->msi.type == PCI_MSI_32_PER_VEC ? "32 bit MSI with per-vector masking" :
+	    d->msi.type == PCI_MSI_64 ? "64 bit MSI" :
+	    d->msi.type == PCI_MSI_64_PER_VEC ? "64 bit MSI with per-vector masking" :
+	    "UNKNOWN",
+	    d->msi.num_vectors_needed);
+}
+
 
 static struct pci_dev*
-pci_dev_create (uint32_t num, struct pci_bus * bus)
+pci_dev_create (struct pci_bus * bus, uint32_t num, uint8_t func ) 
 {
     struct pci_dev * dev = NULL;
     dev = malloc(sizeof(struct pci_dev));
@@ -217,11 +269,14 @@ pci_dev_create (uint32_t num, struct pci_bus * bus)
     memset(dev, 0, sizeof(struct pci_dev));
 
     dev->num = num;
+    dev->fun = func;
 
     pci_copy_cfg_space(dev,bus);
 
     pci_add_dev_to_bus(dev, bus);
 
+    pci_msi_detect(dev);
+
     return dev;
 }
 
@@ -230,7 +285,7 @@ static void
 pci_add_bus (struct pci_bus * bus, struct pci_info * pci)
 {
     pci->num_buses++;
-    list_add( &(bus->bus_node), &(pci->bus_list));
+    list_add_tail( &(bus->bus_node), &(pci->bus_list));
 }
 
 
@@ -255,61 +310,79 @@ pci_bus_create (uint32_t num, struct pci_info * pci)
 }
                 
 
-static void pci_fun_probe(struct pci_info * pci, uint8_t bus, uint8_t dev, uint8_t fun);
+static void pci_pci_bridge_probe(struct pci_info * pci, uint8_t bus, uint8_t dev, uint8_t fun);
 
 
 /*
- *
- * This function probes a particular device on a PCI bus,
- * first by checking if it is indeed a present device, then
- * by checking whether or not it has multiple functions.
- *
+ * This function probes a particular function on a PCI bus.
  */
-static void
-pci_dev_probe (struct pci_bus * bus, uint8_t dev)
+static void pci_func_probe (struct pci_bus * bus, uint8_t dev, uint8_t fun, int *ismultifunc)
 {
-    uint8_t fun = 0;
     uint16_t vendor_id = 0;
     uint8_t hdr_type;
+    
+    *ismultifunc = 0;
 
-    fun = 0;
-
+    //PCI_DEBUG("probing %x:%x:%x\n", bus->num, dev, fun);
+  
     vendor_id = pci_get_vendor_id(bus->num, dev, fun);
 
+
     /* No device present */
     if (vendor_id == 0xffff) {
-        return;
+      //PCI_DEBUG("Skipping nonexistent device %x:%x:%x\n", bus->num, dev, fun);
+      return;
     }
 
     PCI_PRINT("%04d:%02d:%02d.%d %x:%x (rev %d)\n", 0, bus->num, dev, fun, vendor_id, 
             pci_get_dev_id(bus->num, dev, fun), 
             pci_get_rev_id(bus->num, dev, fun));
 
+
     /* create a logical representation of the device */
-    if (pci_dev_create(dev, bus) == NULL) {
+    if (pci_dev_create(bus,dev,fun) == NULL) {
         PCI_ERROR("Could not create PCI device\n");
         return;
     }
 
-    /* does it have multiple functions? */ 
-    pci_fun_probe(bus->pci, bus->num, dev, fun);
+    // If it's a PCI<->PCI bridge, we need to recurse into the child bus
+    pci_pci_bridge_probe(bus->pci, bus->num, dev, fun);
 
     hdr_type = pci_get_hdr_type(bus->num, dev, fun);
 
-    /* multi-function device */
     if ((hdr_type & 0x80) != 0) {
-
         PCI_PRINT("[%04d:%02d.%d] Multifunction Device detected\n", 
-                bus->num, dev, vendor_id);
-
-        // probe the other device functions 
-        for (fun = 1; fun < PCI_MAX_FUN; fun++) {
-            if (pci_get_vendor_id(bus->num, dev, fun) != 0xffff) {
-                PCI_DEBUG("[%04d:%02d.%d] Probing function %02d\n", bus->num, dev, fun, fun);
-                pci_fun_probe(bus->pci, bus->num, dev, fun);
-            }
-        }
+		  bus->num, dev, fun);
+	*ismultifunc = 1;
     }
+
+}
+
+static void pci_dev_probe (struct pci_bus * bus, uint8_t dev)
+{
+  int mf;
+  uint8_t fun;
+  
+  pci_func_probe(bus,dev,0,&mf);
+
+  if (mf) { 
+    for (fun = 1; fun < PCI_MAX_FUN; fun++) {
+      pci_func_probe(bus,dev,fun,&mf);
+    }
+  }
+}
+
+static int pci_already_have_bus(struct pci_info *pci, uint8_t bus_num) 
+{
+  struct list_head *curbus;
+  
+  list_for_each(curbus,&(pci->bus_list)) { 
+    struct pci_bus *bus = list_entry(curbus,struct pci_bus,bus_node);
+    if (bus->num == bus_num) { 
+      return 1;
+    }
+  }
+  return 0;
 }
 
 
@@ -327,6 +400,13 @@ pci_bus_probe (struct pci_info * pci, uint8_t bus)
     uint8_t dev_found = 0;
     struct pci_bus * bus_ptr = NULL;
 
+    //PCI_DEBUG("probing bus 0x%x\n",bus);
+
+    // probe/scan bus only once
+    if (pci_already_have_bus(pci,bus)) { 
+      return;
+    }
+
     /* make sure we actually have at least one device on this bus */
     for (dev = 0; dev < PCI_MAX_DEV; dev++) {
         if (pci_get_vendor_id(bus, dev, 0) != 0xffff) {
@@ -346,6 +426,8 @@ pci_bus_probe (struct pci_info * pci, uint8_t bus)
         for (dev = 0; dev < PCI_MAX_DEV; dev++) {
             pci_dev_probe(bus_ptr, dev);
         }
+    } else {
+      //PCI_DEBUG("not adding bus since it has no devices\n");
     }
 }
 
@@ -358,7 +440,7 @@ pci_bus_probe (struct pci_info * pci, uint8_t bus)
  *
  */
 static void
-pci_fun_probe (struct pci_info * pci, uint8_t bus, uint8_t dev, uint8_t fun)
+pci_pci_bridge_probe (struct pci_info * pci, uint8_t bus, uint8_t dev, uint8_t fun)
 {
     uint8_t base_class; 
     uint8_t sub_class; 
@@ -442,6 +524,8 @@ pci_init (struct naut_info * naut)
     INIT_LIST_HEAD(&(pci->bus_list));
 
     PCI_PRINT("Probing PCI bus...\n");
+
+    // this will miss PCI buses attached to other complexes...
     pci_bus_scan(pci);
 
     naut->sys.pci = pci;
@@ -485,8 +569,38 @@ int pci_map_over_devices(int (*f)(struct pci_dev *d, void *s), uint16_t vendor,
 
 static int dump_dev_base(struct pci_dev *d, void *s)
 {
-  nk_vc_printf("%x:%x.0 : %04x:%04x\n",
-	       d->bus->num, d->num, d->cfg.vendor_id, d->cfg.device_id);
+  uint16_t cmd, status, intr_pin, intr_line;
+
+  cmd=pci_dev_cfg_readw(d,4);
+  status=pci_dev_cfg_readw(d,6);
+
+  nk_vc_printf("%x:%x.%x : %04x:%04x %04xc %04xs ",
+	       d->bus->num, d->num, d->fun, d->cfg.vendor_id, d->cfg.device_id, cmd, status);
+
+  if ((d->cfg.hdr_type&~0x80) ==0 ) { 
+    if (d->msi.co) { 
+      struct pci_msi_info *m = &d->msi;
+      
+      nk_vc_printf("MSI(%s,%s,nn=%d,bv=%d,nv=%d,tc=%d)\n",
+		   m->enabled ? "on" : "off",
+		   m->type == PCI_MSI_32 ? "MSI32" :
+		   m->type == PCI_MSI_32_PER_VEC ? "MSI32wP" :
+		   m->type == PCI_MSI_64 ? "MSI64" :
+		   m->type == PCI_MSI_64_PER_VEC ? "MSI64wP" : "UNKNOWN",
+		   m->num_vectors_needed,
+		   m->base_vec,
+		   m->num_vecs,
+		   m->target_cpu);
+    } else {
+      if (!d->cfg.dev_cfg.intr_pin) {
+	nk_vc_printf("noint\n");
+      } else {
+	nk_vc_printf("legacy(l=%d,p=%d)\n", d->cfg.dev_cfg.intr_line, d->cfg.dev_cfg.intr_pin);
+      }
+    } 
+  } else {
+    nk_vc_printf("not simple device\n");
+  }
   return 0;
 }
 
@@ -497,23 +611,23 @@ int pci_dump_device_list()
 }
 
 struct device_query {
-  uint8_t bus, slot, fun;
+  uint8_t bus, num, fun;
   struct pci_dev *dev;
 };
 
 static int find_dev(struct pci_dev *d, void *s)
 {
   struct device_query *q = (struct device_query *)s;
-  if (d->num==q->slot && d->bus->num==q->bus) { 
+  if (d->num==q->num && d->bus->num==q->bus && d->fun==q->fun) { 
     q->dev = d;
   }
   return 0;
 }
 
 
-struct pci_dev *pci_find_device(uint8_t bus, uint8_t slot, uint8_t fun)
+struct pci_dev *pci_find_device(uint8_t bus, uint8_t num, uint8_t fun)
 {
-  struct device_query q = {.bus=bus, .slot=slot, .fun=fun, .dev=0 };
+  struct device_query q = {.bus=bus, .num=num, .fun=fun, .dev=0 };
   if (pci_map_over_devices(find_dev,-1,-1,&q)) { 
     return 0;
   } else {
@@ -565,14 +679,17 @@ int pci_dump_device(struct pci_dev *d)
 	       d->cfg.class_code==PCI_CLASS_NOCLASS ? "noclass" : "UNKNOWN");
   SHOWIT(cl_size);
   SHOWIT(lat_timer);
-  nk_vc_printf("%-24s: 0x%x (%s)\n",
-	       "hdr_type", d->cfg.hdr_type,
-	       d->cfg.hdr_type==0 ? "device" :
-	       d->cfg.hdr_type==1 ? "PCI<->PCI bridge" : "other");
+  nk_vc_printf("%-24s: 0x%x (","hdr_type", d->cfg.hdr_type);
+  if (d->cfg.hdr_type & 0x80) {
+    nk_vc_printf("multifunction ");
+  }
+  nk_vc_printf("%s)\n",
+	       (d->cfg.hdr_type&~0x80)==0 ? "device" :
+	       (d->cfg.hdr_type&~0x80)==1 ? "PCI<->PCI bridge" : "other");
 
   SHOWIT(bist);
   
-  if (d->cfg.hdr_type==0) { 
+  if ((d->cfg.hdr_type&~0x80)==0) { 
 
 #define SHOWITDEV(x) nk_vc_printf("%-24s: 0x%x\n", #x  , d->cfg.dev_cfg.x)
     SHOWITDEV(bars[0]);
@@ -604,13 +721,6 @@ int pci_dump_device(struct pci_dev *d)
       nk_vc_printf("%02x",data[i]);
     }
     nk_vc_printf("\n");
-#if 1
-    nk_vc_printf("%-24s:   ","data-text");
-    for (i=0;i<48*4;i++) {  
-      nk_vc_printf("%c",isalnum(data[i]) ? data[i] : '.') ;
-    }
-    nk_vc_printf("\n");
-#endif
 
     data = (uint8_t*)&d->cfg;
 
@@ -619,12 +729,11 @@ int pci_dump_device(struct pci_dev *d)
       uint8_t co = d->cfg.dev_cfg.cap_ptr & ~0x3;
       while (co) {
 	uint8_t cap = data[co];
-	co = data[co+1];
 	nk_vc_printf("0x%02x (%s) ", cap,
 		     cap==0x1 ? "PMI" :
 		     cap==0x2 ? "AGP" :
 		     cap==0x3 ? "VPD" :
-		     cap==0x4 ? "SlotID" :
+		     cap==0x4 ? "NumID" :
 		     cap==0x5 ? "MSI" :
 		     cap==0x6 ? "CompactHotSwap" :
 		     cap==0x7 ? "PCI-X" :
@@ -641,12 +750,13 @@ int pci_dump_device(struct pci_dev *d)
 		     cap==0x12 ? "SATADataIndex" :
 		     cap==0x13 ? "PCIAdvancedFeatues" :
 		     cap==0x14 ? "PCIEnhancedAlloc" : "UNKNOWN");
+	co = data[co+1];
       }
       nk_vc_printf("\n");
     }
 		     
 
-  } else if (d->cfg.hdr_type==1) { 
+  } else if ((d->cfg.hdr_type&~0x80)==1) { 
 
 #define SHOWITP2P(x) nk_vc_printf("%-24s: 0x%x\n", #x  , d->cfg.pci_to_pci_bridge_cfg.x)
 
@@ -683,13 +793,7 @@ int pci_dump_device(struct pci_dev *d)
       nk_vc_printf("%02x",data[i]);
     }
     nk_vc_printf("\n");
-#if 1
-    nk_vc_printf("%-24s: ","data-text");
-    for (i=0;i<48*4;i++) {  
-      nk_vc_printf("%c",isalnum(data[i]) ? data[i] : '.') ;
-    }
-    nk_vc_printf("\n");
-#endif
+
   } else {
     nk_vc_printf("No further info for this type\n");
   }
@@ -701,7 +805,7 @@ int pci_dump_device(struct pci_dev *d)
 
 static int dump_dev(struct pci_dev *d, void *s)
 {
-  nk_vc_printf("%-24s: %x:%x.0\n","LOCATION", d->bus->num, d->num);
+  nk_vc_printf("%-24s: %x:%x.%x\n","LOCATION", d->bus->num, d->num, d->fun);
 
   pci_dump_device(d);
 
@@ -715,3 +819,346 @@ int pci_dump_devices()
 {
   return pci_map_over_devices(dump_dev,-1,-1,0);
 }
+ 
+struct dev_match_q {
+  struct pci_dev **list;
+  uint32_t         max;
+  uint32_t         cur;
+};
+
+static int collect_matching(struct pci_dev *d, void *s)
+{
+  struct dev_match_q *q = (struct dev_match_q *)s;
+
+  if (q->cur<q->max) { 
+    q->list[q->cur++] = d;
+  }
+
+  return 0;
+}
+
+
+int pci_find_matching_devices(uint16_t vendor_id, uint16_t device_id,
+			      struct pci_dev *dev[], uint32_t *num)
+{
+  struct dev_match_q q;
+
+  memset(&q,0,sizeof(q));
+
+  q.list = dev;
+  q.max = *num;
+  q.cur = 0;
+
+  if (pci_map_over_devices(collect_matching,vendor_id,device_id,&q)) { 
+    return -1;
+  } else {
+    *num = q.cur;
+    return 0;
+  }
+}
+
+uint16_t pci_dev_cfg_readw(struct pci_dev *dev, uint8_t off)
+{
+  return pci_cfg_readw(dev->bus->num, dev->num, dev->fun, off);
+}
+
+uint32_t pci_dev_cfg_readl(struct pci_dev *dev, uint8_t off)
+{
+  return pci_cfg_readl(dev->bus->num, dev->num, dev->fun, off);
+}
+
+void     pci_dev_cfg_writew(struct pci_dev *dev, uint8_t off, uint16_t val)
+{
+  pci_cfg_writew(dev->bus->num,dev->num,dev->fun,off,val);
+}
+
+void     pci_dev_cfg_writel(struct pci_dev *dev, uint8_t off, uint32_t val)
+{
+  pci_cfg_writew(dev->bus->num,dev->num,dev->fun,off,val);
+}
+
+uint8_t  pci_dev_get_capability(struct pci_dev *d, uint8_t cap_id)
+{
+  if (!(d->cfg.status & (1<<4))) { 
+    //PCI_DEBUG("device has no capabilities\n");
+    return 0;
+  }
+
+  uint8_t *data = (uint8_t*)&d->cfg;
+  uint8_t co = d->cfg.dev_cfg.cap_ptr & ~0x3;
+
+  // scan the cfg space snapshot for the capability 
+  while (co) {
+    uint8_t cap = data[co];
+    if (cap==cap_id) { 
+      //PCI_DEBUG("capability 0x%x found\n", cap_id);
+      return co;
+    }
+    co = data[co+1];
+  }
+  //PCI_DEBUG("capability 0x%x not found\n", cap_id);
+  return co;
+}
+
+
+
+/*
+  the structure of an x86 address register is:
+
+  [32 bits - (presumably top half all zeros...) ]
+
+  [12 bits]  [8 bits]  [8 bits] [1] [1] [2 bits]
+   0xfee      dest_id    rsvd   RH  DM   XX 
+
+  dest_id => equivalent to bits 63:56 of ioapic redirectionentry
+             (physical or logical apic id)
+  RH => redirection hint, 1=> send to lowest priority, 0=> send it
+  DM => destination mode, 1=> interpret dest_id as logical
+  XX => ? probably zero
+
+  the structure of an x86 data register is:
+
+  [32 bits reserved => 0}
+  [16 bits]    [1] [1]  [3]   [3]   [8]
+   rsvd        TM  LEV  rsvd  DM    VEC
+
+   TM = trigger mode, 0=> edge, 1=> level
+   LEV = level for trigger mode, 0=> don't care, else 0/1 = deassert/assert
+   DM = delivery mode (fixed, lowest priority, smi, res, nmi, init, res, extint)
+
+   Intel Volvume 3A, 10.11.1, 10.11.2
+ */
+
+int pci_dev_enable_msi(struct pci_dev *dev, int base_vec, int num_vecs, int target_cpu)
+{
+  uint32_t mar_low;
+  uint16_t mdr;
+  uint16_t ctrl;
+  uint8_t co;
+  int log2_num_vecs;
+  
+  PCI_DEBUG("msi enable - base_vec=0x%x, num_vecs=0x%x, target_cpu=0x%x\n", 
+	    base_vec, num_vecs, target_cpu);
+
+  co = pci_dev_get_capability(dev,0x5);
+
+  if (dev->msi.type==PCI_MSI_NONE || !co) { 
+    PCI_ERROR("device does not support MSI\n");
+    return -1;
+  }
+
+  if (num_vecs<1 || num_vecs>32 || 
+      num_vecs>dev->msi.num_vectors_needed || 
+      __builtin_popcount(num_vecs)!=1 || 
+      base_vec & (num_vecs - 1)) {
+    PCI_ERROR("Invalid MSI enable request\n");
+  }
+
+  log2_num_vecs = 32-__builtin_clz(num_vecs);
+  
+  mar_low  = 0xfee00000;
+  mar_low |= (target_cpu & 0xff) << 12;
+  // we use RH=0 because we don't want lowest priority
+  // we use DM=0 because we want physical delivery
+
+  mdr = (base_vec & 0xff);
+  // We use DM=0 to get fixed delivery
+  // We use LEV=0 because we don't care and are using edge
+  // We use TM=0 to get edge
+  
+  ctrl = pci_dev_cfg_readw(dev,co+2);
+
+  PCI_DEBUG("initial ctrl: 0x%x\n",ctrl);
+
+  ctrl &= 0xff8e;  // clear multiple message enable, clear msi-enable
+  ctrl |= (log2_num_vecs & 0x7)<<4;  // set multiple message enable
+
+  PCI_DEBUG("updated: mdr=0x%x, mar_low=0x%x, ctrl=0x%x\n",mdr,mar_low,ctrl);
+
+  switch (dev->msi.type) { 
+  case PCI_MSI_32:
+    pci_dev_cfg_writel(dev,co+4,mar_low);
+    pci_dev_cfg_writew(dev,co+8,mdr);
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("enabled as MSI32 (masked)\n");
+    break;
+  case PCI_MSI_32_PER_VEC:
+    pci_dev_cfg_writel(dev,co+4,mar_low);
+    pci_dev_cfg_writew(dev,co+8,mdr);
+    pci_dev_cfg_writel(dev,co+12,0xffffffff); // mask all
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("enabled as MSI32 with per vec mask (all masked)\n");
+    break;
+  case PCI_MSI_64:
+    pci_dev_cfg_writel(dev,co+8,0x0); // high addr
+    pci_dev_cfg_writel(dev,co+4,mar_low);
+    pci_dev_cfg_writew(dev,co+12,mdr);
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("enabled as MSI64 (masked)\n");
+    break;
+  case PCI_MSI_64_PER_VEC:
+    pci_dev_cfg_writel(dev,co+8,0x0); // high addr
+    pci_dev_cfg_writel(dev,co+4,mar_low);
+    pci_dev_cfg_writew(dev,co+12,mdr);
+    pci_dev_cfg_writel(dev,co+16,0xffffffff); // mask all
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("enabled as MSI64 with per vec mask (all masked)\n");
+    break;
+  default:
+    PCI_ERROR("Unknown MSI type\n");
+    return -1;
+    break;
+  }
+    
+  dev->msi.base_vec = base_vec;
+  dev->msi.num_vecs = num_vecs;
+  dev->msi.target_cpu=target_cpu;
+  dev->msi.enabled=1;
+
+  PCI_DEBUG("MSI enabled for device\n");
+
+  return 0;
+}
+
+int pci_dev_mask_msi(struct pci_dev *dev, int vec)
+{
+  uint32_t mask;
+  uint16_t ctrl;
+  uint8_t  co;
+
+  if (!dev->msi.enabled) { 
+    PCI_DEBUG("device does not msi enabled\n");
+    return -1;
+  }
+
+  co = dev->msi.co;
+
+  ctrl = pci_dev_cfg_readw(dev,co+2);
+
+  switch (dev->msi.type) { 
+  case PCI_MSI_32:
+  case PCI_MSI_64:
+    // masking means to disable msi
+    ctrl &= ~0x1;
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("masked as a non-per-vec-masking device\n");
+    break;
+  case PCI_MSI_32_PER_VEC:
+    // masking means to enable msi and mask the given vector
+    ctrl |= 0x1;
+    mask=pci_dev_cfg_readl(dev,co+12);
+    mask |= 0x1 << (vec-dev->msi.base_vec);
+    pci_dev_cfg_writel(dev,co+12,mask);
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("masked as a 32 bit per-vec-masking device\n");
+    break;
+  case PCI_MSI_64_PER_VEC:
+    // masking means to enable msi and mask the given vector
+    ctrl |= 0x1;
+    mask=pci_dev_cfg_readl(dev,co+16);
+    mask |= 0x1 << (vec-dev->msi.base_vec);
+    pci_dev_cfg_writel(dev,co+16,mask);
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("masked as a 64 bit per-vec-masking device\n");
+    break;
+  default:
+    PCI_ERROR("Unknown MSI type\n");
+    return -1;
+    break;
+  }
+
+  return 0;
+}
+
+
+int pci_dev_unmask_msi(struct pci_dev *dev, int vec)
+{
+  uint32_t mask;
+  uint16_t ctrl;
+  uint8_t co;
+
+  if (!dev->msi.enabled) { 
+    PCI_DEBUG("device does not msi enabled\n");
+    return -1;
+  }
+
+  co = dev->msi.co;
+
+  ctrl = pci_dev_cfg_readw(dev,co+2);
+
+  switch (dev->msi.type) { 
+  case PCI_MSI_32:
+  case PCI_MSI_64:
+    // unmasking means to enable msi
+    ctrl |= 0x1;
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("unmasked as a non-per-vec-masking device\n");
+    break;
+  case PCI_MSI_32_PER_VEC:
+    // unmasking means to enable msi and unmask the given vector
+    ctrl |= 0x1;
+    mask=pci_dev_cfg_readl(dev,co+12);
+    mask &= ~(0x1 << (vec-dev->msi.base_vec));
+    pci_dev_cfg_writel(dev,co+12,mask);
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("unmasked as a 32 bit per-vec-masking device\n");
+    break;
+  case PCI_MSI_64_PER_VEC:
+    // unmasking means to enable msi and unmask the given vector
+    ctrl |= 0x1;
+    mask=pci_dev_cfg_readl(dev,co+16);
+    mask &= ~(0x1 << (vec-dev->msi.base_vec));
+    pci_dev_cfg_writel(dev,co+16,mask);
+    pci_dev_cfg_writew(dev,co+2,ctrl);
+    PCI_DEBUG("unmasked as a 64 bit per-vec-masking device\n");
+    break;
+  default:
+    PCI_ERROR("Unknown MSI type\n");
+    return -1;
+    break;
+  }
+
+  return 0;
+}
+
+
+int pci_dev_is_pending_msi(struct pci_dev *dev, int vec)
+{
+  uint32_t pending;
+  uint8_t  co;
+
+  if (!dev->msi.enabled) { 
+    PCI_DEBUG("device does not msi enabled\n");
+    return 0;
+  }
+
+  co = dev->msi.co;
+  
+  switch (dev->msi.type) {
+  case PCI_MSI_32:
+  case PCI_MSI_64:
+    pending=0;
+    PCI_DEBUG("pending is zero for a non-per-vector device\n");
+    break;
+  case PCI_MSI_32_PER_VEC:
+    pending=pci_dev_cfg_readl(dev,co+16);
+    break;
+  case PCI_MSI_64_PER_VEC:
+    pending=pci_dev_cfg_readl(dev,co+20);
+    break;
+  default:
+    PCI_ERROR("Unknown MSI type - returning pending=0\n");
+    pending=0;
+    break;
+  }
+
+  pending = (pending >> (vec-dev->msi.base_vec)) & 0x1;
+
+  PCI_DEBUG("pending of vector %d is %d\n", vec, pending);
+
+  return pending;
+
+}
+
+
+
-- 
1.9.1

