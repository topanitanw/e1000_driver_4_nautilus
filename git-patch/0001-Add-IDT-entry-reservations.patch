From 1764209cdc64c532ac6e85ad4f11a004bc93aba3 Mon Sep 17 00:00:00 2001
From: Peter Dinda <pdinda@northwestern.edu>
Date: Wed, 23 Aug 2017 15:30:28 -0500
Subject: [PATCH 1/3] Add IDT entry reservations

This allows us to search for a block (possibly aligned) of vectors
and reserve them.  This is needed for MSI and possibly MSI-X
---
 include/nautilus/idt.h |  2 ++
 src/nautilus/idt.c     | 65 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 67 insertions(+)

diff --git a/include/nautilus/idt.h b/include/nautilus/idt.h
index f36ba4e..4f36301 100644
--- a/include/nautilus/idt.h
+++ b/include/nautilus/idt.h
@@ -125,6 +125,8 @@ int setup_idt(void);
 int idt_assign_entry(ulong_t entry, ulong_t handler_addr, ulong_t state_addr);
 int idt_get_entry(ulong_t entry, ulong_t *handler_addr, ulong_t *state_addr);
 
+int idt_find_and_reserve_range(ulong_t numentries, int aligned, ulong_t *first);
+
 int null_excp_handler(excp_entry_t * excp, excp_vec_t vec, addr_t fault_addr, void * state_addr);
 int null_irq_handler(excp_entry_t * excp, excp_vec_t vector, void * state_addr);
 
diff --git a/src/nautilus/idt.c b/src/nautilus/idt.c
index 3e1fe1e..c1a0717 100644
--- a/src/nautilus/idt.c
+++ b/src/nautilus/idt.c
@@ -139,6 +139,21 @@ null_irq_handler (excp_entry_t * excp,
     return 0;
 }
 
+int
+reserved_irq_handler (excp_entry_t * excp,
+		      excp_vec_t vector,
+		      void       *state)
+{
+  printk("[Reserved IRQ] (vector=0x%x)\n    RIP=(%p)     (core=%u)\n", 
+	 vector,
+	 (void*)excp->rip,
+	 my_cpu_id());
+  printk("You probably have a race between reservation and assignment....\n");
+  printk("   you probably want to mask the interrupt first...\n");
+
+  return 0;
+}
+
 
 static int
 df_handler (excp_entry_t * excp,
@@ -175,6 +190,14 @@ idt_assign_entry (ulong_t entry, ulong_t handler_addr, ulong_t state_addr)
         return -1;
     }
 
+#ifndef NAUT_CONFIG_REMOTE_DEBUGGING
+    if (idt_handler_table[entry]!=(ulong_t)null_excp_handler &&
+	idt_handler_table[entry]!=(ulong_t)null_irq_handler &&
+	idt_handler_table[entry]!=(ulong_t)reserved_irq_handler) { 
+      WARN_PRINT("Assigning to non-null/non-reserved IDT entry...\n");
+    }
+#endif
+
     idt_handler_table[entry] = handler_addr;
     idt_state_table[entry]   = state_addr;
 
@@ -197,6 +220,48 @@ idt_get_entry (ulong_t entry, ulong_t *handler_addr, ulong_t *state_addr)
 }
 
 
+int idt_find_and_reserve_range(ulong_t numentries, int aligned, ulong_t *first)
+{
+  ulong_t h, s;
+  int i,j;
+
+  if (numentries>32) { 
+    return -1;
+  }
+
+  for (i=32;i<(NUM_IDT_ENTRIES-numentries+1);) {
+
+    if (idt_handler_table[i]==(ulong_t)null_irq_handler) { 
+      for (j=0; 
+	   (i+j)<NUM_IDT_ENTRIES && 
+	     j<numentries &&
+	     idt_handler_table[i+j]==(ulong_t)null_irq_handler;
+	   j++) {
+      }
+
+      if (j==numentries) { 
+	// found it!
+	for (j=0;j<numentries;j++) { 
+	  idt_handler_table[i+j]=(ulong_t)reserved_irq_handler;
+	}
+	*first=i;
+	return 0;
+      } else {
+	if (aligned) { 
+	  i=i+numentries;
+	} else {
+	  i=i+j;
+	}
+      }
+    } else {
+      i++;
+    }
+  }
+
+  return -1;
+}
+
+
 extern void early_irq_handlers(void);
 extern void early_excp_handlers(void);
 
-- 
1.9.1

